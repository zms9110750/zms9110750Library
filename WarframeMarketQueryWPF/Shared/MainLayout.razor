@using System.Reflection
@inherits LayoutComponentBase

<MApp>
    <MAppBar App>
        <MToolbarTitle> @currentTitle </MToolbarTitle>
        <MSpacer></MSpacer>
        <MSwitch @bind-Value="CanWrite" Inset><LabelContent>可编辑</LabelContent></MSwitch>
        <MSpacer></MSpacer>
        @msg
    </MAppBar>
    <MNavigationDrawer App Permanent MiniVariant>
        <MList Nav Routable>
            @foreach (var navItem in navItems)
            {
                <MListItem Href="@navItem.Route" ActiveClass="primary--text" OnClick="() => currentTitle = navItem.Title">
                    <MListItemIcon>
                        <MIcon>@navItem.Icon</MIcon>
                    </MListItemIcon>
                    <MListItemContent>
                        <MListItemTitle>@navItem.Title</MListItemTitle>
                    </MListItemContent>
                </MListItem>
            }
        </MList>
    </MNavigationDrawer>

    <MMain>
        <MContainer Fluid>
            <MErrorHandler>
                <CascadingValue Value="CanWrite" Name="CanWrite">
                    @Body
                </CascadingValue>
            </MErrorHandler>
        </MContainer>
    </MMain>
</MApp>
@inject NavigationManager Navigation
@code {

    bool CanWrite;
    string msg;

    protected override async Task OnInitializedAsync()
    {
        var local = await Fusion.GetOrDefaultAsync<string>(nameof(Version).ToLower(), null);
        if (local == null)
        {
            msg = "初始化缓存，请等待";
            await wmClient.GetAndSetIndexByItemAsync();
            msg = "缓存更新完成。请重启程序";
        }
        else
        {
            msg = "本地数据版本" + local + " , 查询服务器数据版本";
            var server = (await wmClient.GetVersionAsync()).ApiVersion;
            if (local == server)
            {
                msg = "本地数据已是最新";
            }
            else
            {
                msg = "后台更新缓存" + local + "/" + server;
                await wmClient.GetAndSetIndexByItemAsync();
                msg = "缓存更新完成";
            }
        }
        await base.OnInitializedAsync();
    }

    string currentTitle = "";
    private List<NavItemInfo> navItems = new();

    protected override void OnInitialized()
    {
        navItems = GetNavItemsFromAssembly();
        currentTitle = navItems.FirstOrDefault(s => s.Route == "/")?.Title ?? "";
    }

    private List<NavItemInfo> GetNavItemsFromAssembly()
    {
        var items = new List<NavItemInfo>();
        var assembly = Assembly.GetExecutingAssembly();

        var pageTypes = assembly.GetTypes()
            .Where(t => t.GetCustomAttribute<RouteAttribute>() != null &&
                       t.GetCustomAttribute<NavItemAttribute>() != null);

        foreach (var type in pageTypes)
        {
            var routeAttr = type.GetCustomAttribute<RouteAttribute>();
            var navAttr = type.GetCustomAttribute<NavItemAttribute>();

            if (routeAttr != null && navAttr != null)
            {
                items.Add(new NavItemInfo
                {
                    Route = routeAttr.Template,
                    Title = navAttr.Title,
                    Icon = navAttr.Icon,
                    Order = navAttr.Order
                });
            }
        }

        return items.OrderBy(x => x.Order).ToList();
    }

    private class NavItemInfo
    {
        public string Route { get; set; } = string.Empty;
        public string Title { get; set; } = string.Empty;
        public string Icon { get; set; } = string.Empty;
        public int Order { get; set; }
    }
}
